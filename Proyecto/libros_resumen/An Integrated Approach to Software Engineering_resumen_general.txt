### Parte 1 (Pág. 1–30)
### Resumen de las Páginas 1-30 de "An Integrated Approach to Software Engineering" (Tercera Edición)

#### **1. Introducción a la Ingeniería de Software**

**1.1. El Dominio del Problema**  
La ingeniería de software aborda los desafíos inherentes al desarrollo de **software de nivel industrial**, caracterizado por:  
- **Alto costo**: El software representa una inversión significativa en recursos económicos y humanos.  
- **Entregas tardías e incumplimiento de plazos**: Proyectos que exceden los tiempos estimados.  
- **Falta de confiabilidad**: Productos con defectos críticos que afectan su funcionalidad.  
- **Mantenimiento y retrabajo**: Hasta el 60% del esfuerzo se destina a modificaciones post-lanzamiento, evidenciando problemas en la calidad inicial.

**1.2. Desafíos de la Ingeniería de Software**  
- **Escala**: Complejidad creciente en sistemas modernos que requieren gestión de equipos y componentes interdependientes.  
- **Calidad y productividad**: Necesidad de equilibrar eficiencia en el desarrollo con estándares de calidad exigentes.  
- **Consistencia y repetibilidad**: Garantizar que los procesos sean predecibles y replicables en distintos contextos.  
- **Gestión del cambio**: Adaptación a requisitos evolutivos y entornos dinámicos.

**1.3. Enfoque de la Ingeniería de Software**  
Se propone un **proceso de desarrollo por fases**, que incluye:  
- **Fases clave**: Análisis de requisitos, diseño, implementación, pruebas y mantenimiento.  
- **Gestión del proceso**: Planificación, monitoreo y control para asegurar el cumplimiento de objetivos.  
- **Modelos de proceso**: Enfoques estructurados para organizar las actividades de desarrollo.

---

#### **2. Procesos de Software**

**2.1. Conceptos Fundamentales**  
- **Proceso de software**: Conjunto de actividades, métodos y prácticas para desarrollar y mantener software.  
- **Modelos de proceso**: Representaciones abstractas que definen flujos de trabajo (ej.: cascada, iterativo).  
- **Procesos componentes**: Subprocesos especializados como gestión de configuración, inspecciones y gestión de cambios.  
- **Especificación ETVX (Entry-Task-Validation-eXit)**: Método para definir procesos mediante criterios de entrada, tareas, validación y salida.

**2.2. Características Deseables de un Proceso**  
- **Predictibilidad**: Capacidad de estimar costos, tiempos y recursos.  
- **Soporte para pruebas y mantenibilidad**: Diseño que facilita la verificación y evolución del software.  
- **Manejo proactivo de cambios**: Mecanismos para incorporar modificaciones sin comprometer la estabilidad.  
- **Eliminación temprana de defectos**: Detección y corrección de errores en fases iniciales.  
- **Mejora continua**: Retroalimentación para optimizar procesos iterativamente.

**2.3. Modelos de Desarrollo**  
- **Modelo en Cascada (Waterfall)**: Fases secuenciales con retroalimentación limitada entre etapas.  
- **Prototipado**: Creación de versiones preliminares para refinar requisitos.  
- **Desarrollo Iterativo**: Ciclos repetitivos que incrementan funcionalidades.  
- **Timeboxing**: Entregas parciales en intervalos fijos para priorizar funcionalidades críticas.  
- **Comparativa**: Se analizan ventajas/desventajas según el contexto del proyecto.

**2.4. Otros Procesos Asociados**  
- **Gestión de proyectos**: Planificación, asignación de recursos y seguimiento.  
- **Inspecciones**: Revisiones formales para identificar defectos en artefactos.  
- **Gestión de configuración**: Control de versiones y cambios en componentes.  
- **Gestión de cambios en requisitos**: Procesos para evaluar y incorporar modificaciones.  
- **Gestión de procesos**: Definición, medición y optimización de los procesos mismos.

---

#### **Conclusiones Clave**  
1. La ingeniería de software surge como respuesta a la complejidad y los riesgos en el desarrollo de sistemas.  
2. La adopción de procesos estructurados es crucial para garantizar calidad, predictibilidad y mantenibilidad.  
3. La selección del modelo de proceso depende de factores como escala, flexibilidad requerida y criticidad del software.  
4. La integración de procesos auxiliares (gestión, calidad, cambios) es tan relevante como las fases de desarrollo centrales.

Este resumen sintetiza los fundamentos presentados en la introducción del texto, estableciendo las bases para temas avanzados como análisis de requisitos, arquitectura y planificación de proyectos.


### Parte 2 (Pág. 31–60)
## Resumen de Páginas 31-60: El Enfoque de la Ingeniería de Software

### 1.3. El Enfoque de la Ingeniería de Software

#### 1.3.1. Proceso de Desarrollo por Fases

**Definición Fundamental**: El proceso de desarrollo de software se estructura en fases secuenciales, cada una con entregables específicos, siguiendo un modelo de proceso determinado.

**Justificación del Enfoque por Fases**:
- Reduce la complejidad mediante división del problema
- Permite control de calidad y seguimiento en puntos definidos
- Minimiza costos de desarrollo
- Facilita la gestión de proyectos complejos

**Fases Fundamentales del Proceso**:

**1. Análisis de Requisitos**
- **Propósito**: Comprender el problema que el sistema debe resolver
- **Enfoque**: Identificar QUÉ se necesita, no CÓMO implementarlo
- **Actividades principales**:
  - Comprensión del problema y su contexto
  - Especificación de requisitos
- **Producto**: Documento de Especificación de Requisitos de Software que incluye:
  - Requisitos funcionales y de rendimiento
  - Formatos de entrada/salida
  - Restricciones de diseño
  - Manual de usuario preliminar

**2. Diseño de Software**
- **Propósito**: Planificar la solución al problema especificado
- **Transición**: Del dominio del problema al dominio de la solución
- **Niveles de diseño**:
  - **Diseño de Arquitectura**: Componentes/subsistemas y sus interconexiones
  - **Diseño de Alto Nivel**: Módulos y sus especificaciones
  - **Diseño Detallado**: Lógica interna de cada módulo

**3. Codificación**
- **Objetivo**: Traducir el diseño a código en un lenguaje específico
- **Criterios de calidad**:
  - Legibilidad y comprensibilidad del código
  - Simplicidad y claridad
  - Reducción del esfuerzo de prueba y mantenimiento

**4. Pruebas**
- **Función principal**: Detección de defectos en el software
- **Tipos de pruebas**:
  - Pruebas unitarias (módulos individuales)
  - Pruebas de integración (interconexiones)
  - Pruebas del sistema (requisitos globales)
  - Pruebas de aceptación (datos reales del cliente)
- **Documentación del proceso**:
  - Plan de pruebas
  - Especificación de casos de prueba
  - Informes de pruebas y errores

#### 1.3.2. Gestión del Proceso

**Necesidad de Gestión**: El proceso de desarrollo por sí solo no especifica:
- Asignación de recursos
- Programación de actividades
- División del trabajo
- Gestión de riesgos
- Control de calidad

**Actividad Central**: **Planificación del Proyecto**
- Establece la línea base para monitoreo y control
- Es fundamental para alcanzar objetivos de costo y calidad
- Sin planificación adecuada, es improbable cumplir con los objetivos del proyecto

### Conclusión

El enfoque de ingeniería de software presentado enfatiza la separación entre proceso y producto, destacando que la calidad del proceso determina fundamentalmente la calidad del producto final. La estructuración en fases permite gestionar la complejidad inherente al desarrollo de software, mientras que la gestión del proceso asegura la ejecución efectiva de estas fases dentro de las restricciones del proyecto.


### Parte 3 (Pág. 61–90)
## Resumen de Modelos de Procesos de Desarrollo de Software (Páginas 61-90)

### 1. Modelo Iterativo

**Definición**: Estrategia de desarrollo que divide el ciclo de vida del software en ciclos repetitivos, donde cada iteración produce una versión funcional del sistema.

**Características principales**:
- **Planificación por riesgos**: Cada iteración comienza identificando y analizando riesgos
- **Desarrollo incremental**: Se añaden funcionalidades progresivamente
- **Retroalimentación continua**: Los usuarios proporcionan feedback después de cada versión

**Aplicaciones**:
- **Desarrollo de productos**: Los desarrolladores controlan las especificaciones
- **Software personalizado**: Adaptación a requisitos cambiantes del negocio
- **Enfoques modernos**: XP (Programación Extrema), Agile, RUP (Rational Unified Process)

### 2. Modelo Timeboxing

**Definición**: Modelo de desarrollo iterativo donde la unidad básica es el "time box" de duración fija, priorizando el cronograma sobre la funcionalidad.

**Elementos clave**:

**Estructura del Time Box**:
- Duración fija e innegociable
- Secuencia de etapas claramente definidas
- Duración aproximadamente igual para cada etapa
- Equipos dedicados por etapa

**Mecanismo de Ejecución**:
- **Pipeline de desarrollo**: Ejecución paralela de múltiples iteraciones
- **Equipos especializados**: Cada etapa tiene su propio equipo
- **Entregas continuas**: Intervalos de entrega reducidos mediante paralelismo

**Ejemplo de Implementación**:
- **3 etapas**: Especificación de requisitos, construcción, despliegue
- **Equipos**: Análisis (2 personas), Construcción (4 personas), Despliegue (3 personas)
- **Beneficio**: Reducción del tiempo promedio de entrega de T a T/n

**Ventajas**:
- Entrega más rápida de software funcional
- Compromiso con cronogramas fijos
- Aprovechamiento óptimo de recursos mediante paralelismo

**Limitaciones**:
- Incremento significativo en el tamaño del equipo
- Requiere arquitectura y tecnologías estables
- Necesita flexibilidad en la agrupación de funcionalidades

### 3. Comparativa de Modelos

**Criterios de Selección**:
- **Naturaleza del proyecto**: Estabilidad de requisitos, complejidad técnica
- **Restricciones temporales**: Urgencia en las entregas
- **Recursos disponibles**: Tamaño y especialización del equipo
- **Flexibilidad requerida**: Capacidad de adaptación a cambios

**Consideraciones de Implementación**:
- El modelo timeboxing permite comprimir tiempos mediante recursos adicionales
- El modelo iterativo ofrece mayor adaptabilidad a cambios
- La selección del modelo debe basarse en el contexto específico del proyecto

Esta sección establece las bases para comprender cómo diferentes modelos de proceso pueden optimizar el desarrollo de software según las características particulares de cada proyecto y las restricciones organizacionales.


### Parte 4 (Pág. 91–120)
## Resumen de Páginas 91-120: Procesos de Software y Especificación de Requisitos

### I. Procesos de Desarrollo de Software (Páginas 91-92)

#### Ejercicios de Aplicación de Modelos de Proceso
El texto presenta una serie de ejercicios prácticos que exploran la selección y diseño de procesos de software:

**Selección de Modelos de Desarrollo:**
- **Proyecto de procesamiento de datos simple:** Modelo en cascada por su predictibilidad
- **Sistema de entrada de datos para usuarios novatos:** Modelo iterativo con énfasis en prototipado de interfaz
- **Sistema de comparación de huellas dactilares:** Modelo evolutivo dada la incertidumbre técnica
- **Sistema de hoja de cálculo con características básicas y avanzadas:** Modelo basado en componentes

**Modelo Timeboxing:**
- Analiza el impacto de etapas de duración desigual en la utilización de recursos
- Propone estrategias de planificación para maximizar eficiencia
- Examina consecuencias de desviaciones temporales en iteraciones

### II. Especificación de Requisitos de Software (Páginas 94-97)

#### 3.1 Conceptos Fundamentales de Requisitos

**Definición Clave (IEEE):**
- "Condición o capacidad necesaria para resolver un problema o alcanzar un objetivo"
- "Condición o capacidad que debe poseer un sistema para satisfacer un contrato o especificación"

**Naturaleza del Problema:**
- Los requisitos iniciales son inherentemente **informales e imprecisos**
- Surgen de necesidades en la mente de múltiples stakeholders
- Presentan problemas de **completitud y consistencia**

#### 3.1.1 Necesidad de la Especificación de Requisitos de Software (SRS)

**Propósito Principal:**
- Establecer base de acuerdo entre cliente y desarrollador
- Servir como referencia para validación del producto final
- Reducir la brecha de comunicación entre dominio del problema y solución técnica

**Impacto en Calidad:**
- Estudios citados (Boehm) indican que **25% de errores** se originan en fases de requisitos y diseño temprano
- Proyecto A-7: 80 errores detectados en documento de requisitos
- Otros casos reportan 250-500 errores en SRS previamente aprobados

**Beneficios Clave:**
1. **Base contractual** para desarrollo
2. **Mecanismo de validación** del producto final
3. **Reducción de costos** mediante detección temprana de errores
4. **Mejora de calidad** del producto final

### III. Conclusión

La especificación de requisitos representa una actividad crítica donde la naturaleza informal de las necesidades iniciales debe transformarse en un documento formal y preciso. La calidad del SRS impacta directamente en el éxito del proyecto, afectando costos, cronogramas y satisfacción del cliente. Los errores en esta fase tienen consecuencias significativas en etapas posteriores del ciclo de desarrollo.


### Parte 5 (Pág. 121–150)
## Resumen de las Páginas 121-150: Análisis y Especificación de Requisitos de Software

### Introducción al Modelado Orientado a Objetos

El texto presenta un enfoque sistemático para el análisis de requisitos mediante modelado orientado a objetos, utilizando como ejemplo ilustrativo un sistema de farmacia (Drugstore) y posteriormente un sistema de restaurante.

### Modelo de Farmacia: Ejemplo Práctico

**Estructura de Clases Identificadas:**
- **Drug-Store**: Clase principal que agrega Medicine y Chemist
- **Chemist**: Atributos (Name, Registration No., Address) y servicio ChemistSales()
- **Medicine**: Clase base con atributos (Name, Quantity, Expiry-date) y servicios (Expired(), OutOfStock())
- **Off-the-shelf**: Especialización de Medicine con atributo qty-on-shelf
- **Prescription**: Especialización con atributos especializados (Refrigeration Needs, Warnings)
- **Sale**: Asociada con Medicine mediante relación 1:M

### Proceso de Análisis de Requisitos

#### 1. Identificación de Objetos y Clases
**Definición**: Un objeto durante el análisis representa una encapsulación de atributos que proporciona servicios exclusivos, representando entidades del dominio del problema.

**Criterios de Identificación:**
- Sustantivos en la descripción del problema
- Entidades que requieren almacenamiento de información
- Elementos que proporcionan servicios necesarios
- Objetos con múltiples atributos (evitar objetos con un solo atributo)

#### 2. Identificación de Estructuras
**Estructuras de Clasificación** (Generalización-Especialización):
- Identificar clases generales y sus especializaciones
- Las especializaciones deben ser significativas para el dominio

**Estructuras de Ensamblaje** (Relaciones Todo-Parte):
- Considerar objetos como ensamblajes y identificar componentes
- Modelar partes solo si el sistema necesita rastrearlas

#### 3. Identificación de Atributos
**Características:**
- Repositorios de datos para objetos
- Accesibles solo mediante funciones de servicio
- Dependen del contexto del problema
- Posicionamiento según estructuras (atributos comunes en superclases)

#### 4. Identificación de Asociaciones
**Tipos de Conexiones:**
- 1:1 (uno a uno)
- 1:M (uno a muchos)
- M:M (muchos a muchos)
- Conexiones multi-vía (menos comunes)

**Consideraciones:**
- Las asociaciones pueden tener atributos propios
- No forzar atributos en objetos si no pertenecen naturalmente

#### 5. Definición de Servicios
**Categorías:**
- **Servicios Ocur**: Creación, destrucción y mantenimiento de instancias
- **Servicios Específicos**: Dependen de la funcionalidad del sistema

**Método de Identificación:**
- Definir estados del sistema
- Listar eventos externos y respuestas requeridas
- Identificar servicios necesarios por clase

### Ejemplo Práctico: Sistema de Restaurante

**Clases Iniciales Identificadas:**
- Restaurant, Bill, Menu, CustomerOrder, SupplyOrder, Supply Handling

**Estructura Final:**
- **Restaurant**: Agregación de Menu y Supply handling
- **Menu**: Agregación de MenuItems
- **SupplyOrder**: Agregación de SupplyItems

**Atributos Específicos:**
- **MenuItem**: Number, Name, Price, Supplies used
- **SupplyItem**: Item name, Unit price

### Gestión de Complejidad en Modelos Grandes

**Estrategia Propuesta:**
- Uso de **capas de sujeto** (subject layers)
- Partición del diagrama de clases en sujetos relacionados
- Cada sujeto contiene clases relacionadas

### Conclusiones Clave

El proceso de análisis presentado enfatiza la importancia de:
1. La identificación natural de objetos basada en el dominio del problema
2. La estabilidad de los objetos frente a cambios en interfaces y funciones
3. La necesidad de que las estructuras reflejen jerarquías naturales del dominio
4. La importancia de considerar solo entidades relevantes para los objetivos del sistema

Este enfoque proporciona una metodología sistemática para transformar descripciones de problemas en modelos orientados a objetos estructurados, facilitando la especificación precisa de requisitos de software.


### Parte 6 (Pág. 151–180)
## Resumen de Páginas 151-180: Especificación Funcional con Casos de Uso y Validación de Requisitos

### 3.4 Especificación Funcional con Casos de Uso

#### 3.4.1 Conceptos Fundamentales

**Caso de Uso**: Representación de la interacción entre actores y el sistema para alcanzar un objetivo específico. Se caracteriza por:
- **Actor primario**: Entidad que inicia la interacción
- **Alcance**: Contexto organizacional del caso de uso
- **Precondiciones**: Condiciones necesarias antes de la ejecución
- **Escenario principal de éxito**: Secuencia básica de pasos para alcanzar el objetivo

#### 3.4.2 Niveles de Abstracción en el Desarrollo de Casos de Uso

El desarrollo evolutivo de casos de uso se estructura en cuatro niveles naturales:

1. **Actores y Objetivos**
   - Enumeración de casos de uso y actores asociados
   - Definición del alcance del sistema
   - Evaluación de completitud funcional

2. **Escenarios Principales de Éxito**
   - Especificación del comportamiento del sistema
   - Verificación de intereses de stakeholders
   - Validación del comportamiento deseado

3. **Condiciones de Falla**
   - Identificación de posibles fallos en cada paso
   - Enumeración exhaustiva de situaciones especiales
   - Base para reglas de negocio adicionales

4. **Manejo de Fallas**
   - Especificación de comportamiento ante condiciones de error
   - Identificación de nuevos actores y reglas de negocio
   - Nivel más complejo de desarrollo

#### 3.4.3 Proceso de Desarrollo Iterativo

El análisis mediante casos de uso sigue un enfoque iterativo:
1. Identificación inicial de actores y objetivos
2. Desarrollo de escenarios principales
3. Enumeración de condiciones de falla
4. Especificación del manejo de fallas

### 3.5 Validación de Requisitos

#### 3.5.1 Importancia y Objetivos

La validación busca garantizar que el documento SRS (Software Requirements Specification):
- Refleje fielmente los requisitos reales
- Sea de calidad adecuada
- Minimice costos de corrección mediante detección temprana de errores

#### 3.5.2 Clasificación de Errores en Requisitos

Los errores se clasifican en cuatro categorías principales:

1. **Omisión (26-32%)**: Requisito no incluido en el SRS
2. **Inconsistencia (13-38%)**: Contradicciones internas o con el entorno
3. **Hecho Incorrecto (10-49%)**: Información errónea en el SRS
4. **Ambigüedad (5-26%)**: Requisitos con múltiples interpretaciones

#### 3.5.3 Métodos de Validación

**Revisión de Requisitos**: Inspección grupal del SRS que incluye:
- Autor del documento de requisitos
- Representantes del cliente y usuarios
- Miembros del equipo de diseño
- Responsables de mantenimiento
- Ingenieros de calidad de software

#### 3.5.4 Objetivos de la Revisión

La revisión se enfoca en:
- Detección de errores de los cuatro tipos mencionados
- Evaluación de calidad del documento (legibilidad, testeabilidad)
- Verificación de completitud y consistencia
- Validación de adecuación a necesidades del cliente

### Conclusiones Relevantes

El enfoque presentado enfatiza:
- La naturaleza iterativa del desarrollo de casos de uso
- La importancia de la validación temprana para reducir costos
- La necesidad de participación activa de stakeholders
- La complementariedad entre especificación funcional (casos de uso) y validación sistemática

Este marco metodológico proporciona una base sólida para el desarrollo de requisitos de software de calidad, equilibrando especificación funcional detallada con procesos rigurosos de validación.


### Parte 7 (Pág. 181–210)
## Resumen de Arquitectura de Software: Vistas y Componentes (Páginas 181-210)

### Introducción a las Vistas de Arquitectura

La arquitectura de software se representa mediante múltiples vistas que capturan diferentes aspectos del sistema, análogamente a como en arquitectura civil se utilizan planos distintos para diferentes sistemas (eléctrico, estructural, etc.). La Figura 4.1 ilustra las principales categorías de vistas:

**Vistas Principales:**
- **Vistas de Componentes y Conectores (C&C):** Estructuras en tiempo de ejecución
- **Vistas de Módulos:** Estructuras de código
- **Vistas de Asignación:** Relaciones software-entorno

### Selección de Vistas Arquitectónicas

La elección de vistas necesarias depende fundamentalmente de:
- **Naturaleza del proyecto:** Complejidad y criticidad
- **Propiedades a analizar:** Rendimiento, desarrollo, mantenimiento
- **Recursos disponibles:** Equipos de desarrollo, infraestructura

**Ejemplos de aplicación:**
- Para análisis de rendimiento: Se requieren vistas C&C y de asignación
- Para planificación del desarrollo: Vista de módulos para asignación de equipos
- Proyectos complejos: Múltiples vistas para análisis multidimensional

### Vista de Componentes y Conectores (C&C)

#### 4.3.1 Componentes

**Definición:** Unidades de computación o almacenes de datos con presencia durante la ejecución del sistema.

**Características esenciales:**
- **Nombre:** Identificador único que representa la función del componente
- **Tipo:** Categoría genérica que define computación e interfaces (ej: cliente, servidor, filtro)
- **Puertos/Interfaces:** Puntos de comunicación con otros componentes

**Representación en diagramas:**
- Se recomienda notación diferenciada por tipo de componente
- Componentes del mismo tipo usan símbolos idénticos, diferenciados por nombre
- Necesidad de clave explicativa debido a la falta de estandarización

#### 4.3.2 Conectores

**Definición:** Mecanismos de interacción entre componentes que definen cómo se comunican durante la ejecución.

**Tipología:**
- **Simples:** Llamadas a procedimiento, mecanismos del sistema operativo
- **Complejos:** Llamadas a procedimiento remoto (RPC), puertos TCP/IP, HTTP
- **N-arios:** Comunicación múltiple (ej: bus de difusión)

**Especificación de conectores:**
- **Nombre:** Describe la naturaleza de la interacción
- **Tipo:** Define propiedades como aridad y tipos de interfaces soportadas
- **Protocolo:** Secuencia de eventos, agrupación de datos, condiciones de error

**Consideraciones de implementación:**
- Los conectores pueden requerir infraestructura compleja (ej: CORBA, ORB)
- Es preferible utilizar conectores disponibles en la plataforma objetivo
- La implementación puede estar distribuida y requerir software adicional

### Representación Gráfica y Estructura

La vista C&C se representa como un grafo donde:
- **Nodos:** Componentes
- **Aristas:** Conectores

**Buenas prácticas de documentación:**
- Uso de símbolos diferenciados para tipos de componentes y conectores
- Inclusión de claves explicativas para la interpretación
- Especificación clara de protocolos e interfaces

### Conclusión

La vista de Componentes y Conectores constituye la vista primaria en arquitectura de software, proporcionando la base para el análisis de propiedades de ejecución y sirviendo como punto de referencia para otras vistas arquitectónicas. Su correcta especificación es fundamental para la implementación exitosa del sistema y el análisis de sus propiedades de calidad.


### Parte 8 (Pág. 211–240)
## Resumen de las Páginas 211-240: Evaluación y Resumen de Arquitectura de Software

### 4.6 Evaluación de Arquitecturas

#### 4.6.2 Ejemplo de Aplicación del ATAM

Se presenta un estudio de caso del sistema de encuestas estudiantiles utilizando el Architecture Tradeoff Analysis Method (ATAM). Se analizan tres arquitecturas alternativas bajo diferentes escenarios y atributos de calidad.

**Escenarios de Evaluación:**
- S1: Envío normal de encuesta con servidores operativos
- S2: Intentos múltiples de envío
- S3: Caída temporal del servidor de base de datos
- S4: Sistema altamente cargado

**Requisitos del Sistema:**
- **Seguridad:** Limitación de un envío por estudiante
- **Tiempo de Respuesta:** < 2 segundos en 80% de los casos
- **Disponibilidad:** Mínimo 0.85
- **Actualidad de Datos:** Resultados no mayores a 5 envíos anteriores

**Metodología de Análisis:**
- Para disponibilidad y tiempo de respuesta: modelos probabilísticos
- Para seguridad y actualidad de datos: análisis cualitativo basado en comprensión arquitectónica

**Resultados del Análisis Comparativo:**
La Tabla 4.1 muestra que:
- Todas las arquitecturas cumplen con seguridad y actualidad de datos
- Solo las arquitecturas 2 y 3 satisfacen el requisito de disponibilidad
- La arquitectura 3 presenta mejores tiempos de respuesta promedio (550 ms vs 1150 ms)

**Puntos de Sensibilidad y Compromisos:**
- El servidor se identifica como punto de compromiso crítico
- La replicación mejora disponibilidad pero afecta rendimiento de actualización

### 4.7 Resumen de Arquitectura de Software

#### Definición Fundamental
La arquitectura de software representa el diseño de alto nivel del sistema en términos de sus componentes y sus relaciones. Se define como "las estructuras del sistema que comprenden elementos software, sus propiedades externamente visibles y las relaciones entre ellos".

#### Vistas Arquitectónicas Principales

**1. Vista de Módulos**
- Sistema como estructura de módulos de programación
- Elementos: paquetes, clases, funciones
- Enfoque en construcción futura

**2. Vista de Componentes y Conectores (C&C)**
- Sistema como colección de entidades en tiempo de ejecución
- **Componentes:** entidades runtime
- **Conectores:** mecanismos de interacción
- Relación no necesariamente directa con vista de módulos

**3. Vista de Asignación**
- Distribución de unidades software en recursos hardware
- Relación con aspectos físicos del sistema

#### Estilos Arquitectónicos Comunes

**Pipe and Filter**
- Componente: Filtro
- Conector: Tubería
- Restricción: Conexión exclusiva mediante tuberías

**Client-Server**
- Componentes: Cliente y Servidor
- Conector: Request/Reply
- Restricción: Iniciación por cliente

**Shared Data**
- Componentes: Repositorio y Accesadores de datos
- Mecanismo: Compartición mediante repositorio

**Otros Estilos:**
- Publish-Subscribe
- Peer-to-Peer
- Procesos Comunicantes

#### Documentación Arquitectónica

**Elementos Esenciales:**
1. **Contexto:** Stakeholders y objetivos
2. **Vistas Arquitectónicas:** Especificación completa
3. **Relaciones entre Vistas:** Integración coherente
4. **Rationale Arquitectónico:** Justificación de decisiones

**Buenas Prácticas:**
- Selección de vista primaria como eje central
- Combinación de vistas sin complicar diagramas
- Especificación clara de tipos de elementos y comportamiento externo
- Documentación del proceso de toma de decisiones

### Conclusión

La arquitectura de software constituye la base fundamental para el desarrollo de sistemas de calidad, permitiendo el análisis temprano de propiedades críticas como rendimiento y disponibilidad. La evaluación sistemática mediante métodos como ATAM facilita la selección de arquitecturas óptimas que balanceen adecuadamente los diferentes atributos de calidad del sistema.


### Parte 9 (Pág. 241–270)
## Resumen de Planificación de Proyectos de Software (Páginas 241-270)

### 5.4 Planificación de Gestión de Configuración
La planificación de Gestión de Configuración (CM) se realiza al inicio del proyecto cuando se conocen el entorno operativo y las especificaciones de requisitos. Las actividades clave incluyen:

- **Identificación de elementos de configuración**, incluyendo elementos suministrados por el cliente y adquiridos
- **Definición de esquema de nomenclatura** para elementos de configuración
- **Estructura de directorios** necesaria para CM
- **Procedimientos de gestión de versiones** y métodos de seguimiento de cambios
- **Restricciones de acceso** y procedimientos de control de cambios
- **Identificación de responsabilidades** del Controlador de Configuración (CC)
- **Puntos de creación de líneas base**
- **Procedimientos de respaldo, reconciliación y liberación**

El resultado de esta fase es el **Plan de Gestión de Configuración**.

### 5.5 Plan de Calidad

#### 5.5.1 Definiciones Fundamentales
- **Calidad del software**: Definida como "densidad de defectos entregados" - número de defectos por unidad de tamaño en el software entregado
- **Defecto**: Elemento en el software que causa comportamiento inconsistente con los requisitos del cliente
- **Control de Calidad (QC)**: Actividades cuyo propósito principal es identificar defectos

#### 5.5.2 Ciclo de Inyección y Eliminación de Defectos
El desarrollo de software es propenso a errores, con defectos que pueden inyectarse en múltiples etapas:

**Etapas de inyección**:
- Especificación de requisitos
- Diseño de alto nivel
- Diseño detallado
- Codificación

**Actividades de eliminación**:
- Revisiones de requisitos, diseño y código
- Pruebas unitarias, de integración, de sistema y de aceptación
- Actividades de Verificación y Validación (V&V)

#### 5.5.3 Enfoques de Gestión de Calidad

**Enfoque Procedimental**:
- Ejecución de procesos definidos en puntos específicos
- No permite afirmaciones sobre porcentaje de defectos eliminados
- Depende de la calidad del procedimiento y su ejecución

**Enfoque Cuantitativo**:
- **Predicción de defectos**: Establecimiento de metas de densidad de defectos
- **Control Estadístico de Procesos (SPC)**: Establecimiento de límites de control para actividades de QC
- Requiere datos históricos para estimaciones

#### 5.5.4 Elementos del Plan de Calidad
El plan de calidad especifica:
- Tareas de control de calidad programables
- Documentos y código a inspeccionar
- Niveles de prueba a realizar
- Métodos, responsabilidades y criterios de evaluación para actividades V&V

### 5.6 Gestión de Riesgos

#### 5.6.1 Conceptos Fundamentales
- **Riesgo**: Exposición a la posibilidad de daño o pérdida que afecta adversamente coste, calidad o cronograma
- **Gestión de riesgos**: Minimización del impacto de eventos no planificados
- Se enfoca en eventos probabilísticos, no en eventos comúnmente esperados

#### 5.6.2 Actividades de Gestión de Riesgos
El proceso comprende tres fases principales:

1. **Identificación de Riesgos**
2. **Evaluación de Riesgos**
   - Análisis de riesgos
   - Priorización de riesgos
3. **Control de Riesgos**
   - Planificación de gestión de riesgos
   - Resolución de riesgos
   - Monitoreo de riesgos

La gestión de riesgos es considerada una de las mejores prácticas para gestionar proyectos de software grandes, complementando la gestión de proyectos convencional al tratar eventos infrecuentes con impacto significativo.


### Parte 10 (Pág. 271–300)
## Resumen de las páginas 271-300: Conceptos de Diseño Orientado a Funciones

### 6.2 Conceptos a Nivel de Módulo

#### 6.2.1 Acoplamiento (Coupling)

**Definición**: El acoplamiento entre módulos es la fuerza de interconexión entre módulos o una medida de interdependencia entre ellos. Representa cuánto debemos conocer sobre el módulo A para entender el módulo B.

**Factores que afectan el acoplamiento**:

1. **Complejidad de la interfaz**: Se reduce manteniendo interfaces simples y pequeñas
2. **Tipo de conexión**: Las conexiones directas y obvias reducen el acoplamiento
3. **Tipo de comunicación**: 
   - Comunicación de datos: menor acoplamiento
   - Comunicación de control: acoplamiento moderado
   - Comunicación híbrida: mayor acoplamiento

**Tipos de acoplamiento**:
- **Módulos altamente acoplados**: Unidos por interconexiones fuertes
- **Módulos débilmente acoplados**: Interconexiones débiles
- **Módulos independientes**: Sin interconexiones

#### 6.2.2 Cohesión

**Definición**: La cohesión de un módulo representa qué tan estrechamente vinculados están los elementos internos del módulo entre sí. Indica si los diferentes elementos de un módulo pertenecen juntos en el mismo módulo.

**Niveles de cohesión** (de menor a mayor):

1. **Coincidental**: No existe relación significativa entre los elementos
2. **Lógica**: Elementos realizan funciones de la misma clase lógica
3. **Temporal**: Elementos relacionados en tiempo y ejecutados juntos
4. **Procedural**: Elementos pertenecen a una unidad procedural común
5. **Comunicacional**: Elementos relacionados por referencia a los mismos datos de entrada/salida
6. **Secuencial**: La salida de un elemento forma la entrada de otro
7. **Funcional**: Todos los elementos están relacionados con realizar una sola función

**Relación entre cohesión y acoplamiento**: Generalmente, a mayor cohesión de cada módulo en el sistema, menor es el acoplamiento entre módulos.

### Técnica para Determinar Cohesión Funcional

Para verificar si un módulo tiene cohesión funcional:
1. Escribir una oración que describa completa y precisamente la función del módulo
2. Aplicar las siguientes pruebas:
   - Si la oración es compuesta o tiene más de un verbo: probable cohesión secuencial o comunicacional
   - Si contiene palabras temporales ("primero", "siguiente"): cohesión secuencial o temporal
   - Si el predicado no contiene un objeto específico: cohesión lógica
   - Palabras como "inicializar" o "limpiar" implican cohesión temporal

### 6.3 Notación de Diseño y Especificación

Durante la fase de diseño existen dos elementos de interés:
- El diseño del sistema (producción como actividad básica)
- La especificación del diseño

### Conclusiones Clave

1. El acoplamiento se determina principalmente durante el diseño del sistema y no puede reducirse durante la implementación
2. La cohesión funcional representa el nivel ideal de diseño modular
3. Existe una relación inversa entre cohesión y acoplamiento: sistemas bien diseñados maximizan la cohesión y minimizan el acoplamiento
4. La evaluación de la cohesión requiere juicio de diseño más que fórmulas matemáticas

Estos conceptos fundamentales proporcionan las bases para evaluar y mejorar la calidad del diseño de software orientado a funciones, facilitando sistemas más mantenibles, comprensibles y modificables.


### Parte 11 (Pág. 301–330)
## Resumen de Métricas de Diseño en Ingeniería de Software (Páginas 301-330)

### Introducción
Esta sección aborda métricas cuantitativas para evaluar la calidad del diseño orientado a funciones, centrándose en estabilidad del diseño, flujo de información y complejidad modular.

### 6.6 Métricas de Diseño

#### 6.6.1 Métricas de Estabilidad del Diseño

**Definición Clave**: La estabilidad del diseño mide la susceptibilidad de un módulo a generar efectos de propagación (ripple effect) ante cambios.

**Procedimiento de Cálculo de Estabilidad**:

1. **Análisis de Dependencias**:
   - Jx = {módulos que invocan a x}
   - J^x = {módulos invocados por x}
   - Rxy = {parámetros retornados de x a y}
   - R^xy = {parámetros pasados de x a y}
   - GRx = {datos globales referenciados en x}
   - GDx = {datos globales definidos en x}

2. **Cálculo de Suposiciones**:
   - TPxy: Suposiciones sobre parámetros retornados
   - TP^xy: Suposiciones sobre parámetros pasados
   - TGx: Suposiciones sobre datos globales modificados

3. **Métricas de Estabilidad**:
   - DLRE (Design Logical Ripple Effect): 
     ```
     DLREx = TGx + ΣTPxy + ΣTP^xy
     ```
   - Estabilidad del Módulo: 
     ```
     DSx = 1/(1 + DLREx)
     ```
   - Estabilidad del Programa: 
     ```
     PDS = 1/(1 + ΣDLREx)
     ```

**Aplicación**: Las métricas de estabilidad permiten comparar diseños alternativos e identificar módulos con alto acoplamiento para posibles rediseños.

#### 6.6.3 Métricas de Flujo de Información

**Concepto Fundamental**: La complejidad de un módulo depende de su complejidad interna y de las interconexiones con otros módulos.

**Modelos de Complejidad**:

1. **Modelo Basado en Tamaño y Flujo**:
   ```
   Dc = tamaño * (entrada * salida)²
   ```
   Donde:
   - Entrada: elementos de datos que fluyen hacia el módulo
   - Salida: elementos de datos que fluyen desde el módulo

2. **Modelo Basado en Conectividad**:
   ```
   Dc = fan_in * fan_out + entrada * salida
   ```
   Donde:
   - fan_in: número de módulos que llaman al módulo
   - fan_out: número de módulos llamados por el módulo

**Clasificación de Módulos**:

- **Propensos a errores**: Dc > promedio + desviación estándar
- **Complejos**: promedio < Dc < promedio + desviación estándar
- **Normales**: resto de casos

### 6.7 Resumen del Capítulo

**Definición de Diseño**: Plan de solución que satisface requisitos y preserva la arquitectura del sistema.

**Proceso de Diseño en Dos Niveles**:
1. **Diseño del Sistema**: Define módulos e interacciones
2. **Diseño Detallado**: Especifica lógica de procesamiento y estructuras de datos

**Principios Fundamentales**:
- **Partición de Problemas**: Divide complejidad en problemas más pequeños
- **Abstracción**: Permite concentrarse en componentes individuales
- **Modularidad**: Componentes con abstracciones bien definidas y mínimo impacto ante cambios

**Criterios de Modularidad**:
- **Acoplamiento**: Medida de interdependencia entre módulos
- **Cohesión**: Medida de fuerza de relación entre elementos internos del módulo

### Conclusión
Las métricas presentadas proporcionan herramientas cuantitativas para evaluar y mejorar la calidad del diseño, identificando módulos problemáticos y permitiendo comparaciones entre alternativas de diseño. La validación empírica sugiere que estas métricas correlacionan con la mantenibilidad y propensión a errores del software.


### Parte 12 (Pág. 331–360)
## Resumen de las Páginas 331-360: Conceptos de Diseño Orientado a Objetos

### 1. Herencia: Concepto Fundamental

**Definición**: La herencia es un mecanismo que permite a una clase (denominada subclase o clase derivada) adquirir propiedades y comportamientos de otra clase (superclase o clase base). Esta relación se representa mediante el concepto "es-un" (is-a), donde un objeto de la subclase también es instancia de la superclase.

**Estructura de la Herencia**:
- **Parte Derivada**: Componentes heredados de la clase base
- **Parte Incremental**: Nuevas definiciones y código específico añadido en la subclase

**Características de Redefinición**:
- Modificación de visibilidad de operaciones
- Cambio en la implementación de métodos
- Renombrado o anulación de características heredadas

### 2. Jerarquía de Herencia

**Principio Fundamental**: La jerarquía debe reflejar la estructura del dominio del problema, no simplemente facilitar la reutilización de código.

**Ventajas**:
- Acumulación de características comunes en superclases
- Promoción de reutilización mediante definición de operaciones comunes
- Especialización progresiva mediante subclases

**Consideraciones de Diseño**:
- Dependencia entre subclases y superclases
- Impacto de cambios en superclases sobre subclases herederas
- Implicaciones en el proceso de testing

### 3. Ejemplo Práctico: Sistema Gráfico

Se presenta una jerarquía de clases para un sistema gráfico:

```
GraphicalObject (clase base abstracta)
├── ZeroAreaObject
│   ├── Line
│   └── OpenCurve
└── NonZeroAreaObject
    ├── Polygon
    └── Circle
```

**Conceptos Implementados**:
- **Clases Abstractas**: GraphicalObject contiene operaciones virtuales puras
- **Métodos Virtuales**: Operaciones como move(), rotate(), scale() requieren implementación específica en cada subclase
- **Atributos Protegidos**: Accesibles por subclases pero no públicamente

### 4. Tipos de Herencia

**Herencia Estricta**:
- Subclase hereda todas las características de la superclase
- Añade únicamente características nuevas
- Mantiene relación "es-un" pura

**Herencia No Estricta**:
- Subclase no hereda todas las características
- Puede redefinir características existentes
- Complica el comportamiento dinámico y testing

### 5. Herencia Múltiple

**Definición**: Capacidad de una clase de heredar de múltiples superclases simultáneamente.

**Problemas Asociados**:
- **Ambiguidad de Nombres**: Conflictos cuando múltiples superclases definen características con el mismo nombre
- **Herencia Repetida**: Cuando una clase hereda indirectamente múltiples veces de la misma superclase
- **Complejidad Incremental**: Dificultad en resolución de referencias y mantenimiento

**Recomendación**: Evitar el uso de herencia múltiple debido a su complejidad inherente.

### 6. Polimorfismo

**Definición**: Capacidad de un objeto de pertenecer a diferentes tipos, permitiendo que referencias puedan apuntar a objetos de distintos tipos en tiempo de ejecución.

**Tipos de Polimorfismo**:

**Polimorfismo de Objetos**:
- **Tipo Estático**: Tipo declarado en el texto del programa (invariable)
- **Tipo Dinámico**: Tipo actual del objeto en tiempo de ejecución (puede variar)

**Polimorfismo de Características**:
- **Vinculación Dinámica (Dynamic Binding)**: El código asociado a una llamada a procedimiento se determina en tiempo de ejecución
- Permite que operaciones definidas en superclases sean redefinidas en subclases

### 7. Implicaciones en el Diseño

**Ventajas del Enfoque Orientado a Objetos**:
- Reutilización efectiva de código
- Modelado natural de relaciones del dominio
- Flexibilidad mediante polimorfismo

**Consideraciones de Implementación**:
- Necesidad de soporte lingüístico para herencia y polimorfismo
- Importancia del diseño cuidadoso de jerarquías
- Impacto en estrategias de testing

Este resumen presenta los conceptos fundamentales del diseño orientado a objetos, destacando la herencia como mecanismo central para la especialización y reutilización, y el polimorfismo como facilitador de flexibilidad en el comportamiento del sistema.


### Parte 13 (Pág. 361–390)
## Resumen de las Páginas 361-390: Metodología de Diseño Orientado a Objetos

### 7.5 Metodología de Diseño

#### 7.5.3 Definición de Clases y Operaciones Internas

**Definiciones Clave:**
- **Clases de Contenedor (Container Classes):** Clases identificadas durante la implementación para almacenar resultados intermedios o modelar aspectos específicos de objetos.
- **Clases del Dominio del Problema:** Clases identificadas durante el análisis que representan entidades del dominio del problema.

**Proceso de Implementación:**
1. **Evaluación Crítica de Clases:** Se analiza cada clase para determinar su necesidad en la implementación final.
2. **Implementación de Operaciones:** Se desarrollan algoritmos aproximados para implementar operaciones.
3. **Identificación de Nuevas Clases:** Durante la implementación pueden surgir nuevas clases de soporte para estructuras de datos complejas.

#### 7.5.4 Optimización y Empaquetado

**Estrategias de Optimización:**

1. **Adición de Asociaciones Redundantes**
   - **Propósito:** Mejorar la eficiencia de operaciones frecuentes
   - **Criterio:** Evaluar la relación entre objetos accedidos y objetos seleccionados (hit ratio)
   - **Ejemplo:** Implementación de índices para búsquedas específicas

2. **Almacenamiento de Atributos Derivados**
   - **Definición:** Atributos cuyo valor puede calcularse a partir de otros atributos
   - **Consideraciones:**
     - Frecuencia de uso
     - Complejidad computacional
     - Mantenimiento de consistencia con atributos base

3. **Uso de Tipos Genéricos**
   - **Ventaja:** Reducción del tamaño del código
   - **Implementación:** Definición de clases genéricas que se instancian para tipos específicos

4. **Ajuste de Herencia**
   - **Generalización de Operaciones:** Identificar operaciones comunes para "empujar" hacia clases base
   - **Creación de Clases Abstractas:** Definir superclases significativas que capturen comportamiento común
   - **Criterio:** La jerarquía debe ser "natural" y significativa

**Principios de Diseño:**
- Priorizar comprensibilidad y modularidad sobre eficiencia y compacidad
- Minimizar desviaciones de la estructura lógica del análisis

#### 7.5.5 Ejemplos de Aplicación

**Problema de Conteo de Palabras**

**Modelo de Clases Inicial:**
- **File:** Representa el archivo de entrada
- **Word:** Representa palabras individuales
- **Counter:** Maneja el conteo de palabras únicas
- **History:** Mecanismo para verificar unicidad de palabras

**Modelado Dinámico:**
- Escenario de procesamiento por lotes
- Flujo secuencial: entrada → procesamiento → salida

**Modelo Funcional:**
- Refuerza la necesidad del objeto History
- Identifica operaciones necesarias: increment(), isunique(), addToHistory()

**Decisiones de Implementación:**
- Sustitución de History por Btree (árbol binario de búsqueda)
- Especificación de operaciones de comparación para la clase Word

### Consideraciones Metodológicas Finales

**Naturaleza de las Metodologías:**
- Guías orientativas, no reglas estrictas
- Requieren juicio de ingeniería en cada paso
- El diseño resultante debe considerarse sujeto a modificaciones

**Especificación del Diseño:**
- Documentación completa de clases y métodos
- Especificación de interfaces
- Uso de estructuras de clases del lenguaje de implementación (ej: C++)

Esta sección enfatiza la transición desde el análisis orientado a objetos hacia una implementación práctica, considerando tanto aspectos de diseño lógico como consideraciones de eficiencia y optimización.


### Parte 14 (Pág. 391–420)
## Resumen de las Páginas 391-420: Diseño Detallado y Verificación

### 8.1 Diseño Detallado y PDL

#### 8.1.1 Refinamiento por Pasos (Stepwise Refinement)

**Definición**: Técnica de diseño descendente (top-down) para desarrollar el diseño detallado mediante sucesivas aproximaciones desde especificaciones abstractas hasta implementaciones concretas.

**Características principales**:
- Cada paso de refinamiento representa una o dos decisiones de diseño
- Requiere un lenguaje con flexibilidad para diferentes niveles de precisión
- Los lenguajes de programación convencionales no son adecuados para este propósito

**Lenguaje de Diseño de Programación (PDL)**:
- Sintaxis externa formal que garantiza la conversión posterior a lenguajes de programación
- Sintaxis interna flexible basada en lenguaje natural
- Permite expresar declaraciones con distintos grados de precisión

**Ejemplo de aplicación**: Sistema de conteo de palabras diferentes en archivo de texto
- Estrategia inicial: lectura del archivo, ordenamiento de lista y conteo de palabras diferentes
- Refinamientos sucesivos de operaciones:
  - Lectura desde archivo (Figura 8.4)
  - Conteo de palabras diferentes (Figura 8.5)
  - Ordenamiento de lista

**Estrategias de refinamiento**:
- **Profundidad primero (Depth-first)**: Completar el refinamiento de una operación antes de proceder con otras
- **Amplitud primero (Breadth-first)**: Refinar todas las operaciones necesarias en cada nivel antes de proceder al siguiente nivel
- **Combinación**: Uso mixto de ambas estrategias

#### 8.1.2 Comparación con Diseño Estructurado

**Diferencias fundamentales**:
- En refinamiento por pasos, la función de ordenamiento es subordinada al módulo principal
- En diseño estructurado, el ordenamiento es subordinado al módulo de entrada
- El refinamiento por pasos se enfoca en especificar operaciones necesarias
- El diseño estructurado se centra en particionar el problema en módulos de entrada, salida y transformación

#### 8.1.3 Modelado de Estados para Clases

**Contexto**: Enfoque necesario para diseño orientado a objetos donde las clases no pueden tratarse como abstracciones funcionales.

**Conceptos clave**:
- **Estado del objeto**: Valor de sus atributos en un momento dado
- **Evento**: Ejecución de una operación sobre el objeto
- **Estado lógico**: Combinación de estados desde los cuales el comportamiento del objeto es similar para todos los eventos posibles

**Modelado mediante Autómatas Finitos de Estados (FSA)**:
- Estados representan condiciones lógicas del objeto
- Transiciones ocurren cuando se ejecutan operaciones
- Estado inicial desde el cual todos los demás estados son alcanzables

**Ejemplo aplicado**: Pila de tamaño acotado (Figura 8.6)
- Estados lógicos: Pila vacía, pila con elementos, pila llena
- Comportamientos diferenciados para operaciones push, pop y top según el estado

**Utilidad del modelado de estados**:
- Comprensión de efectos de operaciones sobre el estado del objeto
- Desarrollo de lógica para operaciones individuales
- Validación de corrección de implementaciones
- Generación de casos de prueba (Capítulo 10)

### 8.2 Verificación del Diseño Detallado

**Objetivo**: Demostrar que el diseño detallado cumple con las especificaciones del diseño del sistema.

#### 8.2.1 Recorridos de Diseño (Design Walkthroughs)

**Definición**: Método manual de verificación mediante revisión informal por pares.

**Características**:
- Reunión informal convocada por el diseñador o líder del grupo
- Grupo pequeño (diseñador, líder y/o otro diseñador)
- Explicación paso a paso de la lógica del diseño
- Identificación de errores y búsqueda de clarificaciones

**Beneficios**:
- El proceso de explicación ayuda al diseñador a descubrir errores
- Revisión por pares
- Naturaleza informal

**Limitaciones**: Menos efectivo que las revisiones formales de diseño

#### 8.2.2 Revisión Crítica de Diseño (Critical Design Review)

**Propósito**: Asegurar que el diseño detallado satisface las especificaciones del diseño del sistema.

**Proceso**: Similar al proceso de inspecciones con grupo de revisión que incluye:
- Autor del diseño detallado
- Miembro del equipo de diseño del sistema
- Programador responsable de la codificación
- Ingeniero de calidad de software independiente

**Enfoque**:
- Descubrir errores de diseño, no corregirlos
- La corrección se realiza posteriormente
- Uso de listas de verificación (checklists) para evaluación sistemática

**Conclusión**: La combinación de técnicas de refinamiento sistemático con métodos de verificación formal e informal constituye un enfoque integral para garantizar la calidad del diseño detallado en ingeniería de software.


### Parte 15 (Pág. 421–450)
## Resumen de las Páginas 421-450: Principios y Procesos de Codificación

### 9.1.5 Estándares de Codificación

**Definición:** Los estándares de codificación constituyen un conjunto de reglas y directrices que regulan aspectos específicos de la programación con el objetivo fundamental de mejorar la legibilidad y mantenibilidad del código.

#### Convenciones de Nomenclatura
- **Nombres de paquetes:** Deben escribirse en minúsculas (ej: `mypackage`, `edu.iitk.maths`)
- **Nombres de tipos:** Deben ser sustantivos que inicien con mayúscula (ej: `Day`, `DateOfBirth`)
- **Nombres de variables:** Sustantivos en minúscula (ej: `name`, `amount`)
- **Constantes:** Completamente en mayúsculas (ej: `PI`, `MAX_ITERATIONS`)
- **Métodos:** Verbos en minúscula (ej: `getValue()`)
- **Variables de clase privadas:** Sufijo `_` (ej: `private int value_`)
- **Variables booleanas:** Prefijo `is` (ej: `isStatus`)

#### Organización de Archivos
- Archivos fuente Java deben tener extensión `.java`
- Cada archivo debe contener una clase externa cuyo nombre coincida con el nombre del archivo
- Longitud de línea limitada a 80 columnas

#### Directrices para Declaraciones
- Variables deben inicializarse donde se declaran
- Variables relacionadas deben declararse juntas
- Variables de clase nunca deben ser públicas
- Evitar construcciones complejas en bucles y condicionales

### 9.1.6 Comentarios y Diseño

**Concepto Clave:** Los comentarios deben explicar **qué** hace el código o **por qué** existe, no traducir la lógica al inglés. Cuando la lógica es tan compleja que requiere comentarios extensos, es preferible refactorizar el código.

**Prólogo de Módulo:** Comentarios que describen:
- Funcionalidad y propósito del módulo
- Interfaz pública y forma de uso
- Parámetros y efectos secundarios
- Suposiciones sobre los parámetros

### 9.2 Proceso de Codificación

#### 9.2.1 Proceso de Codificación Incremental

**Definición:** Enfoque donde el código se desarrolla en incrementos funcionales, con pruebas después de cada adición.

**Ventajas:**
- Facilita la depuración al aislar errores al código recién añadido
- Permite detección temprana de defectos
- Facilita la integración continua

**Requisito:** Scripts de prueba automatizados que permitan ejecución frecuente de casos de prueba.

#### 9.2.2 Desarrollo Guiado por Pruebas (TDD)

**Definición:** Metodología donde primero se escriben las pruebas y posteriormente el código necesario para pasarlas.

**Proceso TDD (Figura 9.3):**
1. Escribir prueba que falle
2. Escribir código mínimo para pasar la prueba
3. Refactorizar el código
4. Repetir el ciclo

**Características Principales:**
- **Enfoque uso-conducido:** El desarrollo se centra en cómo se usará el código
- **Sincronización código-pruebas:** El código siempre está alineado con las pruebas
- **Responsabilidad transferida:** Las pruebas garantizan que se implemente la funcionalidad requerida
- **Especificación precisa:** Las pruebas definen claramente la interfaz de uso

**Beneficios:**
- Cobertura de pruebas más completa
- Diseño más orientado al uso
- Documentación ejecutable a través de las pruebas
- Detección temprana de problemas de diseño

Este enfoque, aunque originado en Programación Extrema (XP), es aplicable independientemente de la metodología de desarrollo utilizada.


### Parte 16 (Pág. 451–480)
## Resumen de las páginas 451-480: Verificación de Programas

### 9.4. VERIFICACIÓN

#### 9.4.3 Demostración de Correctitud

**Definición Clave**: La demostración de correctitud constituye una aproximación formal para establecer matemáticamente que un programa satisface su especificación formal.

**Características Fundamentales**:
- Requiere especificaciones formales precisas (precondiciones y postcondiciones)
- Establece la correctitud directamente, a diferencia de otras técnicas que solo detectan errores
- Resulta más efectiva cuando se integra durante el desarrollo del programa

**Conceptos Esenciales**:
- **Precondición**: Aserción que define las condiciones de entrada válidas
- **Postcondición**: Aserción que especifica el estado final esperado
- **Terminación**: Condición que garantiza que la ejecución finalizará

#### Método Axiomático de Floyd-Hoare

**Base Teórica**: Modelo axiomático propuesto por Hoare que utiliza aserciones de la forma:
```
P {S} Q
```
Donde P es la precondición, S el segmento de programa y Q la postcondición.

**Axiomas y Reglas Fundamentales**:

1. **Axioma de Asignación**:
   ```
   P^f {x := f} P
   ```
   Donde P^f se obtiene sustituyendo todas las ocurrencias de x por f en P.

2. **Regla de Composición**:
   ```
   P {S1} Q, Q {S2} R
   ────────────────────
      P {S1; S2} R
   ```

3. **Regla para Sentencias Alternativas**:

   **If-then-else**:
   ```
   P∧B {S1} Q, P∧¬B {S2} Q
   ──────────────────────────
      P {if B then S1 else S2} Q
   ```

   **If-then**:
   ```
   P∧B {S} Q, P∧¬B ⇒ Q
   ─────────────────────
      P {if B then S} Q
   ```

4. **Reglas de Consecuencia**:
   - Si P ⇒ P' y P' {S} Q' y Q' ⇒ Q, entonces P {S} Q
   - Permiten fortalecer precondiciones y debilitar postcondiciones

#### Análisis Estático Automatizado

**Propósito**: Detección de errores mediante análisis del código fuente sin ejecución.

**Ventajas Identificadas**:
- Detección coste-efectiva de errores
- Identificación directa de defectos (no solo su presencia)
- Reducción significativa del debugging posterior

**Limitaciones**:
- Generación de falsos positivos
- Esfuerzo adicional para verificar advertencias
- Posible desconfianza del programador hacia alertas válidas

**Ejemplo de Errores Detectados**:
- Fugas de memoria (memory leaks)
- Desreferenciación de punteros no inicializados
- Acceso a punteros NULL

#### Aplicación Práctica

**Contexto de Uso**:
- Lenguajes de programación procedural simples
- Constructores básicos: asignación, condicionales, iteración
- Especificaciones formales como base del proceso

**Metodología**:
1. Definición formal de precondiciones y postcondiciones
2. Aplicación sistemática de axiomas y reglas
3. Construcción incremental de demostraciones
4. Verificación de terminación para programas iterativos

**Relevancia Actual**: Incremento en entornos comerciales debido a su escalabilidad y efectividad en la detección de errores complejos.

Este enfoque integrado combina métodos formales con herramientas automatizadas, proporcionando un marco robusto para el desarrollo de software confiable y verificable.


### Parte 17 (Pág. 481–510)
## Resumen de las Páginas 481-485: Fundamentos de Pruebas de Software

### 1. Definiciones Fundamentales

**Error**: Se define de dos maneras:
- Discrepancia entre un valor calculado, observado o medido y el valor verdadero, especificado o teóricamente correcto
- Acción humana que resulta en software que contiene un defecto o falla

**Falla (Fault)**: Condición que causa que un sistema falle en el desempeño de su función requerida. Sinónimo del término común "bug". En software, todas las fallas son "fallas de diseño" - no existe desgaste en software.

**Fracaso (Failure)**: Incapacidad de un sistema o componente para realizar una función requerida según sus especificaciones. Ocurre cuando el comportamiento del software difiere del comportamiento especificado.

### 2. Relaciones entre Conceptos

- La presencia de un error implica que debe haber ocurrido un fracaso
- La observación de un fracaso implica que debe existir una falla en el sistema
- La presencia de una falla **no** garantiza que ocurra un fracaso
- Las fallas son condición necesaria pero **no suficiente** para que ocurran fracasos

### 3. Implicaciones para el Proceso de Pruebas

- Las pruebas solo pueden revelar la **presencia** de fallas, **no su ausencia**
- La no observación de fracasos durante las pruebas no permite afirmar que no existen fallas en el sistema
- Esto convierte a "cuándo detener las pruebas" en uno de los problemas más difíciles en testing

### 4. Oráculos de Prueba

**Definición**: Mecanismo, diferente del programa mismo, que puede usarse para verificar la corrección de la salida del programa para los casos de prueba.

**Características**:
- Necesarios para realizar pruebas efectivas
- Idealmente deberían ser automatizados y siempre dar respuestas correctas
- Frecuentemente son seres humanos, lo que introduce posibilidad de errores
- Utilizan las especificaciones del programa para determinar el comportamiento "correcto"

**Problemas con los Oráculos**:
- Las especificaciones pueden contener errores, imprecisiones o ambigüedades
- Esto genera situaciones donde diferentes partes pueden discrepar sobre qué constituye un fracaso

### 5. Casos de Prueba y Criterios de Selección

**Caso de Prueba**: Entrada específica utilizada para probar el software.

**Propiedades Deseables**:
- Maximizar el número de errores detectados
- Minimizar el número de casos de prueba (minimizar costo)

**Pruebas Exhaustivas**: Incluir todas las posibles entradas al programa. Es **impráctica e inviable** incluso para programas pequeños debido al tamaño extremo del dominio de entrada.

### 6. Criterios de Selección de Pruebas

**Definición**: Para un programa P y sus especificaciones S, un criterio de selección de pruebas especifica las condiciones que debe satisfacer un conjunto de casos de prueba T.

**Propiedades Fundamentales**:

**Confiabilidad (Reliability)**: Un criterio es confiable si todos los conjuntos de casos de prueba que satisfacen el criterio detectan los mismos errores.

**Validez (Validity)**: Un criterio es válido si para cualquier error en el programa existe algún conjunto que satisface el criterio y revelará el error.

**Teorema Fundamental**: Si un criterio de prueba es válido y confiable, y un conjunto que satisface el criterio tiene éxito (no revela fallas), entonces el programa no contiene errores.

**Limitación Práctica**: No existe algoritmo que pueda determinar un criterio válido para un programa arbitrario, por lo que frecuentemente se usan criterios que no son completamente válidos o confiables.

Este marco conceptual establece las bases fundamentales para comprender la naturaleza, limitaciones y desafíos del proceso de pruebas de software, destacando especialmente la imposibilidad teórica de probar la ausencia total de errores mediante testing convencional.


### Parte 18 (Pág. 511–540)
## Resumen de las Páginas 511-540: Técnicas de Pruebas Estructurales

### 10.3 Pruebas de Caja Blanca (White-Box Testing)

#### **Criterios Basados en Flujo de Datos**

**Definiciones Fundamentales:**
- **def (definición):** Nodo donde una variable recibe un valor
- **c-use (uso computacional):** Uso de una variable en una expresión
- **p-use (uso predictivo):** Uso de una variable en una condición
- **dcu (conjunto de usos computacionales):** Nodos donde una definición se usa computacionalmente
- **dpu (conjunto de usos predictivos):** Arcos donde una definición se usa predictivamente

**Criterios de Cobertura:**

1. **All-Edges (Cobertura de Ramas):**
   - Requiere que cada arista del grafo sea recorrida
   - Ejemplo: Paths (1;2;4;5;6;7;8;9) y (1;3;4;5;7;9)
   - Consideración de **paths no factibles**: caminos que no pueden ejecutarse con ningún dato de prueba

2. **All-Defs (Todas las Definiciones):**
   - Cada definición de variable debe tener al menos un uso (c-use o p-use)
   - Requiere paths adicionales para cubrir redefiniciones
   - Ejemplo: (1;2;4;5;6;5;6;7;8;9) y (1;3;4;5;6;7;9)

3. **All-Uses (Todos los Usos):**
   - Cubre todos los p-uses y c-uses de todas las definiciones
   - En el ejemplo presentado, los paths de all-defs satisfacen también all-uses

#### **10.3.4 Pruebas de Mutación (Mutation Testing)**

**Concepto Fundamental:**
Técnica estructural que genera múltiples **mutantes** del programa mediante cambios simples, evaluando la capacidad del conjunto de pruebas para distinguirlos del programa original.

**Hipótesis de Base:**
1. **Hipótesis del Programador Competente:** Los programadores producen programas "cercanos" al correcto
2. **Efecto de Acoplamiento:** Los casos de prueba que detectan errores simples también detectan errores complejos

**Operadores de Mutación:**
- Cambios sintácticos unitarios en el programa
- Ejemplos:
  - Reemplazo de operadores aritméticos
  - Cambio de referencias a arrays
  - Sustitución de constantes
  - Modificación de etiquetas goto
  - Reemplazo de variables por valores especiales

**Proceso de Pruebas de Mutación:**

1. **Generación de Mutantes:** Aplicación de operadores de mutación (N mutantes totales)
2. **Ejecución y Evaluación:**
   - **Mutantes Distinguidos (Dead):** D mutantes que producen salidas diferentes
   - **Mutantes Equivalentes (E):** Mutantes que siempre producen la misma salida que el original
3. **Cálculo del Puntaje de Mutación:** MS = D/(N - E)
4. **Criterio de Finalización:** MS = 1

**Desafíos Identificados:**
- **Determinación de Equivalencia:** Problema indecidible que requiere análisis manual
- **Generación de Casos de Prueba:** Complejidad para diseñar tests que distingan mutantes específicos
- **Costo Computacional:** Ejecución múltiple de mutantes

**Propiedades de un Caso de Prueba Efectivo:**
1. Debe forzar la ejecución hasta la instrucción mutada
2. Debe generar estados diferentes después de la ejecución de la instrucción mutada
3. Debe propagar las diferencias hasta la salida del programa

Esta sección establece las bases teóricas y prácticas para la aplicación sistemática de criterios estructurales en la ingeniería de software, destacando tanto sus ventajas como limitaciones computacionales y prácticas.


### Parte 19 (Pág. 541–570)
## Resumen de las Páginas 541-570: Modelado y Estimación de Confiabilidad en Ingeniería de Software

### 1. Fundamentos del Modelado de Confiabilidad

**Definición Clave**: La confiabilidad del software se modela mediante la **intensidad de fallos** (λ), que representa la tasa a la que ocurren fallos durante la ejecución del software.

#### Modelo Exponencial de Confiabilidad
- La intensidad de fallos disminuye exponencialmente con el tiempo de ejecución (τ)
- **Ecuación fundamental**: λ(τ) = λ₀ × e^(-λ₀/ν₀ × τ)
- Donde:
  - λ₀: Intensidad inicial de fallos
  - ν₀: Número total esperado de fallos

#### Supuestos del Modelo
- El perfil operacional uniforme garantiza que la reducción de intensidad de fallos sea lineal
- Para perfiles no uniformes, se recomienda el **modelo logarítmico**
- La reducción de intensidad ocurre únicamente cuando se eliminan las fallas detectadas

### 2. Proceso de Estimación de Parámetros

#### Requisitos para la Aplicación del Modelo
- **Recolección sistemática** de datos de fallos durante las pruebas del sistema
- **Tiempo suficiente** de observación para obtener datos significativos
- **Exclusión** de datos de pruebas unitarias y de integración

#### Métodos de Recolección de Datos
1. **Datos de tiempos de fallo**: Registro secuencial de instantes de fallo
2. **Datos agrupados de fallos**: Conteo de fallos en intervalos temporales definidos

### 3. Técnicas de Estimación Estadística

#### Método de Mínimos Cuadrados
- Objetivo: Minimizar la suma de cuadrados de diferencias entre valores observados y predichos
- **Ecuación de regresión**: λ(μ) = λ₀(1 - μ/ν₀)
- Conversión de datos brutos a intensidades de fallo:
  - Para intervalos regulares: rᵢ = k/(tₖᵢ - tₖ₍ᵢ₋₁₎)
  - Para último intervalo: rₚ = (mₑ - k(p-1))/(tₑ - tₖ₍ₚ₋₁₎)

#### Consideraciones Prácticas
- **Tamaño de intervalo óptimo**: k ≈ 5 fallos por intervalo
- **Ponderación de errores**: Preferencia por minimización de error relativo sobre error absoluto
- **Incertidumbre inherente**: Los parámetros estimados siempre contienen cierto grado de incertidumbre

### 4. Aplicaciones Prácticas del Modelo

#### Determinación de Criterios de Finalización de Pruebas
- **Número adicional de fallos esperados**:
  Δμ = (ν₀/λ₀) × (λₚ - λₚ)
- **Tiempo adicional de ejecución requerido**:
  Δτ = (1/λ₀) × ln(λₚ/λₚ)

#### Limitaciones del Enfoque
- **Dependencia del tamaño del software**: Modelos poco efectivos para sistemas pequeños
- **Requisito de datos suficientes**: Necesidad de conjunto extenso de fallos para estimación precisa
- **Influencia del perfil operacional**: La validez del modelo depende de la uniformidad del perfil

### 5. Implicaciones para la Gestión de Proyectos

El modelo permite:
- **Estimación cuantitativa** del esfuerzo de testing restante
- **Conversión a tiempo calendario** mediante parámetros del entorno de desarrollo
- **Toma de decisiones basada en métricas** sobre la finalización de pruebas
- **Establecimiento de objetivos de confiabilidad** medibles y alcanzables

Este enfoque proporciona un marco sistemático para la gestión de la calidad del software mediante métricas de confiabilidad objetivas y cuantificables.


### Parte 20 (Pág. 571–581)
## Resumen de Páginas 571-581: Gestión de Calidad y Métricas en Ingeniería de Software

### 1. Conceptos Fundamentales de Calidad

**Defecto**: Cualquier imperfección o deficiencia en un producto de software que puede manifestarse como un error durante la ejecución. Se clasifica según:
- **Severidad**: Impacto en el sistema (crítico, mayor, menor, cosmético)
- **Tipología**: Naturaleza del defecto (lógico, de interfaz, de rendimiento, etc.)

**Ciclo de Vida del Defecto**:
- Detección y registro
- Análisis y asignación
- Corrección y verificación
- Cierre y documentación

### 2. Prevención de Defectos

**Estrategias Organizacionales**:
- **Análisis Causal**: Identificación sistemática de causas raíz
- **Diagrama Causa-Efecto (Ishikawa)**: Herramienta gráfica para análisis de causas
- **Análisis Pareto**: Técnica estadística para priorizar problemas (80/20)

**Proceso de Prevención**:
1. Recopilación y análisis de datos de defectos
2. Identificación de patrones recurrentes
3. Desarrollo de soluciones preventivas
4. Implementación y seguimiento

### 3. Métricas de Calidad y Productividad

**Métricas Clave**:
- **Eficiencia en Remoción de Defectos (DRE)**: 
  ```
  DRE = (Defectos encontrados antes de liberación) / (Defectos totales) × 100%
  ```
- **Productividad**: Relación entre tamaño del software y esfuerzo requerido
- **Confiabilidad**: Medida mediante:
  - **Intensidad de Fallos**: Frecuencia de ocurrencia de fallos
  - **MTTF (Mean Time To Failure)**: Tiempo promedio entre fallos

### 4. Modelos de Confiabilidad

**Características Esenciales**:
- **Perfil Operacional**: Distribución de probabilidad de entradas en operación real
- **Modelo Básico de Musa**: Modelo matemático para predecir confiabilidad
- **Método Newton-Raphson**: Técnica numérica para estimación de parámetros

### 5. Métricas de Diseño Orientado a Objetos (OOD)

**Métricas Específicas**:
- **Profundidad del Árbol de Herencia (DIT)**: Niveles de herencia de una clase
- **Número de Hijos (NOC)**: Cantidad de subclases directas
- **Acoplamiento entre Clases (CBO)**: Número de clases acopladas
- **Falta de Cohesión en Métodos (LCOM)**: Medida de cohesión interna
- **Respuesta para una Clase (RFC)**: Conjunto de métodos ejecutables
- **Métodos Ponderados por Clase (WMC)**: Complejidad de métodos implementados

### 6. Técnicas de Verificación y Validación

**Verificación de Diseño Detallado**:
- **Revisión de Diseño**: Evaluación formal mediante checklist
- **Walkthrough de Diseño**: Revisión paso a paso con el equipo
- **Revisión de Escritorio**: Evaluación individual del diseñador

**Pruebas Especializadas**:
- **Pruebas por Pares (Pair-wise)**: Combinación sistemática de parámetros
- **Pruebas de Mutación**: Inyección de fallos artificiales para evaluar casos de prueba

### 7. Principios de Programación Robustos

**Buenas Prácticas**:
- Verificación de valores de retorno en operaciones de lectura
- Manejo apropiado de excepciones y bloques finally
- Minimización de efectos secundarios
- Uso restrictivo de goto
- Aplicación de tipos de datos definidos por el usuario
- Control de anidamiento de construcciones

### Conclusión

Las páginas analizadas presentan un marco integral para la gestión de calidad en ingeniería de software, enfatizando la importancia de métricas cuantitativas, procesos sistemáticos de prevención de defectos y técnicas avanzadas de verificación. La integración de estos elementos permite desarrollar software de calidad industrial con niveles predecibles de confiabilidad y mantenibilidad.